"""
Last Modified on 7/31
"""

import numpy as np
import matplotlib.pyplot as plt


class BinHelper:
    def __init__(self):
        """
        :return: A BinHelper object

        Initializer function
        """

        # The final set of probability values we get, if a bin has 10% of values it's position will have 0.1
        self.final_prob_vals = []
        # The data we are using between the min and max values
        self.clipped_data = []
        # The bins limits we are using for the plotting
        self.x_axis = []
        # Flag to show that the user has already generated values
        self.has_vals = False
        return

    def generate_values(self, input_data, min_val, max_val, bin_increment):
        """

        :param input_data: The data we are running through the probability density function. Should be a numpy array
        :param min_val: The min value you wish to see being put in a bucket, leave as None if you don't want one
        :param max_val: The max value you wish to see being put in a bucket, leave as None if you don't want one
        :param bin_increment: The increment to use from bin to bin, leave as None if you want 0.2

        :return: A numpy array of the probabilities associated with each bin

        Will generate the probability density function values from the min value to max value. It counts all data
        between the min and max values in input data, having bins of bin_increment size. Must run before plotting.

        """

        # We check to see if any of these values are not initialized, if they aren't then initialize them
        if bin_increment is None:
            bin_increment = 0.2
        if min_val is None:
            min_val = min(input_data)
        if max_val is None:
            max_val = max(input_data)

        if min_val >= max_val:
            print("The min and max values are either the same or min is larger than max... check your use of this "
                  "function")
            return ValueError

        # The start of the first bin we are looking at starts at the min_val
        curr_bin_start = min_val

        # The clipped_data is all the data we will be looking at, esentially it is between the max and min values
        clipped_data = input_data[(max_val >= input_data) & (input_data >= min_val)]

        # This array will store all of our bins
        bins = []

        # While there are bins left to check
        while curr_bin_start < max_val:
            # The end value is the start of the bin plus the increment
            end_val = curr_bin_start + bin_increment
            # Take all values that are from the start of the bin (inclusive) to the end of the bin (exclusive)
            curr_bin = clipped_data[(end_val > clipped_data) & (clipped_data >= curr_bin_start)]
            # Append all these values to our big bins list
            bins.append(curr_bin)
            # Increment for the while loop
            curr_bin_start = curr_bin_start + bin_increment

        # This list will store all of our probability values and floats
        probability_vals = []

        # For every bin, determine how many values are in it
        for item in bins:
            curr_size = item.size
            probability_vals.append(curr_size)

        # Make an array of the previous list because we have to for division
        probability_vals_arr = np.array(probability_vals)

        # The final probability values are each bin's total divided by all values being looked at
        final_prob_vals = probability_vals_arr / sum(probability_vals)

        # print("Total probability vals is " + str(sum(probability_vals)))
        # print("Total percentage out of 1.0 is " + str(sum(final_prob_vals)))

        # These are the bins we ended up using, we store them for plotting and use later on
        x_axis = np.arange(min_val, max_val, bin_increment)

        # Update object properties
        self.final_prob_vals = final_prob_vals
        self.clipped_data = clipped_data
        self.x_axis = x_axis
        # Say we have the values
        self.has_vals = True

        # Return the final_prob_vals because we are most likely to use these
        return final_prob_vals

    def plot_values(self, label=None):
        """

        :param label: The label of the plot if it has one, such as Hardness or Modulus

        :return: Nothing

        Generates a plot to show the probability function from what was generated by the generate_values method call.
        Warning: can not successfully run this before before the generate_values method is called and executed
        properly.

        """

        # We are using a histogram to plot this
        # The clipped_data serves as the raw data to plot, the x_axis serves as the bins to use, and the
        # weights allow us to set the "y-value" or height of each bad to be that of the percentage of values in
        # the current bin compared to all the data we are looking at
        plt.hist(self.clipped_data, bins=self.x_axis, weights=np.ones(len(self.clipped_data)) / len(self.clipped_data))
        if label is None:
            plt.title(label="Probability Density Function")
            plt.xlabel(xlabel="Bins")
        else:
            plt.title(label="Probability Density Function For " + label)
            plt.xlabel(xlabel=label + " Values")
        plt.ylabel(ylabel="Probability")
        plt.show()

        return
